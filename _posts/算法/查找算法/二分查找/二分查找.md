---
title: 二分查找
author: DXTZ
tags: [二分查找]
categories:
  - [算法, 查找算法, 二分查找]
date: 2020-02-16 13:16:25
---
二分查找，是一种基于比较目标值和中间元素值的一种快速查找算法，时间复杂度仅为 O(log(n))。
其优点是比较次数少，查找速度快，平均性能好；缺点是要求元素有序排列。

<!--more-->
 
## 原理
二分查找的原理很简单，就是“夹逼法”亦或者“排除法”的思想，
即每次向目标范围逼近一半亦或者每次排除掉一半无效范围的元素，具体的：  
首先，
将序列的中间位置的值和目标值进行比较：
- 若两者相等，则查找成功
- 否则若两者不等，由中间位置将目标序列分割为：左子序列，中间位置，右子序列，然后：
    - 若中间位置值小于目标值，则进一步查找右子序列，
        即将右子序列作为新的目标序列进行查找，即将序列的左边界移至中间位置之右
    - 否则若中间位置值大于目标值，则进一步查找左子序列，
        即将左子序列作为新的目标序列进行查找，即将序列的右边界移至中间位置之左

然后重复上述步骤，直至：
- 两者相等，则查找成功，返回对应位置
- 子序列不存在，则查找失败，返回 -1

二分查找的传统版代码如下：
```java 
public int binarySearch(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target)
            return mid;
        else if (nums[mid] < target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return -1;
}
```

## 优化 
以上二分查找的传统版十分易于理解，但存在以下一些细节上的不足，并针对性地进行改良提升：

### 中间位置索引计算，防溢出

传统版中间位置索引计算如下：
```java 
mid = (left + right) / 2; 
```
由于 (left + right) 可能存在溢出（大于 MAX_INT），故修改为：
```java 
mid = left + (right - left) / 2 ;
```
又假若 left 为负，(right - left) 仍可能溢出（概率极小），故进一步修改为：
```java
 mid = (left + right) >>> 1 ; // ">>>" 无符号右移
```
### 查找失败，返回顺序插入位置
传统版对于目标值不存在于目标序列时，仅返回 -1 提示查找失败，不实用  
故将其改良为查找在序列中顺序插入目标值的位置，使算法的实用性更强  
即返回序列中不小于目标值的最小（第一个）索引，没有则返回序列长度（末端元素索引 +1）

该改进相对于传统版而言，仅当查找失败，不存在相等值时，需更为具体地返回顺序插入位置，具体分析如下：  
（*后续分析用 L 表示左端索引，R 表示右端索引，M 表示二分中间点索引，T 表示目标值被顺序插入的位置索引*）
- 当 L 和 R 间隔较大时，必有 T ∈ [L, R]，继续循环查找；
- 当 L 和 R 间隔较小时，迭代情况如下图1：

![二分查找_7.png](https://cdn.jsdelivr.net/gh/CN-DXTZ/Blog-Img-Bed/PicGo/二分查找_7.png)<center>图1</center>

上图1展示了 L 与 R 差为 3, 2, 1, 0 时的所有相对位置情况，并持续迭代直至最终退出循环，实线表示迭代顺序，虚线表示同类情形，四个小格子（为了能表示多种索引在某个位置重叠）为一个大格子表示一个实际序列位置，其中若有重叠，由于 T 的顺序插入原则，必有 nums[T] ≤ nums[L/R/M]，故 T 必显示在左侧以彰显大小关系。
注：图中实线的条件判断存在错误，应为 nums[] 的比较，而非索引的比较。

由上图1可知，当 L 与 R 间隔较小时，有可能出现**蓝色框**中的情形：
即当 M = T = L + 1，R = L + 1 或 L + 2 时，进一步迭代会出现 T ∉ [L, R]，
故需要对最后的情况进行更为详细的分析如下。

显然，根据循环条件，循环终止时，必有 L = R + 1。
而要形成此情况，必为图1中**绿色框**中的情况再循环迭代一步而来。
具体分析而言，迭代的情况只有以下两种：
- L = M 且将执行 R = M - 1：
    由执行 R = M - 1 可知判断条件为 M > T，又 L <= T，故 T = L = M。
    又由 L = M 可知 R = L 或 R = L + 1 如下图2：

![二分查找_5.png](https://cdn.jsdelivr.net/gh/CN-DXTZ/Blog-Img-Bed/PicGo/二分查找_5.png)<center>图2</center>

- R = M 且将执行 L = M + 1：
    由 R = M 可知 L = R ，故 L = R = M：
    由执行 L = M + 1 可知判断条件为 M < T，故只能为 T = M + 1 如下图3：

![二分查找_6.png](https://cdn.jsdelivr.net/gh/CN-DXTZ/Blog-Img-Bed/PicGo/二分查找_6.png)<center>图3</center>

而上述三种情况经过简单计算即可得出结论，必得出图1中下端**红色框**中显示，放大见下图4：

![二分查找_4.png](https://cdn.jsdelivr.net/gh/CN-DXTZ/Blog-Img-Bed/PicGo/二分查找_4.png)<center>图4</center>

故最终必有 L = T。
故此，对于改进的程序返回顺序插入位置，只需在任意查找失败的情况，即循环终止时返回 left 即可。
即最终仅需将 `return -1` 修改为 `return left`

二分查找的优化版代码如下：
```java 
public int binarySearch(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = (left + right) >>> 1; // 防溢出
        if (nums[mid] == target)
            return mid;
        else if (nums[mid] < target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return left; // 返回顺序插入位置
}
```
上述改良提升了算法的实用性，但可扩展性不强，适用范围不广。
因为如需返回序列中不大于目标值的最大（最后一个）索引，则应修改为 `return  right`，
然而对于每一次需求，对于具体返回 left 还是 right ，都需进行上述繁琐的分析，扩展性不强。
故此以下提出更为明晰的方法。
（*下述提及  T ∈ 或 ∉ [L, R] 时，不考虑目标值插入位置不属于目标序列时的情况*）

### 循环终止条件变为 L == R
之所以需要判断最终返回 left 还是 right，是因为最终循环终止的条件是 L > R，
更准确的说此时 L = R + 1，形似 ..., **R], [L**, ...，
此时 L 与 R 反向越界，区间不复存在，故最终需要判断具体返回 left 还是 right。

而通过修改循环条件 `left <= right` 为 `left < right`，即可将循环终止条件变为 L >= R，
试图当 L = R 时退出循环，形似 ..., **[L R]**, ...，
如果成功，此时由于 L = R 二者重合，则无需区分判断。

但由之前的优化分析可知：
当 M = T = L + 1，R = L + 1 或 L + 2 时，进一步迭代会出现 T ∉ [L, R]（见图1**蓝色框**）
而由于修改了循环终止条件，此时又有 L = R 循环终止，故而无法得出正确答案。
故除了上述修改循环终止条件外，还需修改迭代过程，让目标值不超出范围。

### 修改循环迭代过程

由图1**蓝色框**可以看出，造成目标值超出范围的核心在于：
取中间值时是**向下取整**：`M = (L + M) >>> 1`，当 L < R 时必有 M ∈ **[L, R)**
则当 nums[M] < nums[T] 时，L = M + 1 ，必不会使目标值超出范围，
而当 nums[M] > nums[T] 时，R = M - 1，则有可能使得目标值超出范围

故而为使得目标值恒不超出范围，合并 nums[M] > nums[T] 和 nums[M] = nums[T] 的情况：
即当 nums[M] >= nums[T] 时，R = M

故之前的子区间划分 M 为单独项，即分为：[L, M - 1]，[M]，[M + 1, R]，
每次查找失败则将查找区间 [L, R] 缩小一半至 [L, M - 1] 或 [M + 1, R]，
而新的子区间划分不再单独划分 M，分为：[L, M] 和 [M + 1, R]，
每次查找失败则将查找区间 [L, R] 缩小一半至 [L, M] 或 [M + 1, R]，区别如下图5：

![二分查找_12.jpg](https://cdn.jsdelivr.net/gh/CN-DXTZ/Blog-Img-Bed/PicGo/二分查找_12.jpg)<center>图5</center>

通过上述修改循环迭代过程，可以确保当序列中存在大于目标值的元素时，
在迭代的任何阶段，都有 T ∈ [L, R]，
又由之前修改的循环终止条件，保证了最终循环结束时有 L = R，形似 ..., **[L R]**, ...，即最终有 T = L = R。

### 判断目标值插入位置是否在目标序列内
以上基本完善了二分查找，不过对提及  T ∈ 或 ∉ [L, R] 时，未考虑目标值插入位置不属于目标序列时的情况，
而实则在迭代的任何阶段，都有 T ∈ [L, R] **⊆ [0, length - 1]**，但完整的值域应为 **[0, length]**，
即没有考虑，当序列中不存在大于目标值的元素时，需返回序列长度（末端元素索引 +1）。

故此，需要单独判断当序列中不存在大于目标值的元素时，应返回序列长度。
（*也可通过判断最终的 nums[left] 和 target 的大小关系确定是否为该特例*）

故最终二分查找完善版的代码如下：
```java
public int searchInsert(int[] nums, int target) {
    // 序列中不存在大于目标值的元素，返回序列长度
    if (nums[nums.length - 1] < target)
        return nums.length;
    int left = 0, right = nums.length - 1;
    while (left < right) { // left == right 退出，无需判断
        int mid = (left + right) >>> 1; // 防溢出
        // 小于目标值，[L, M]都不符合，全部剔除 => [M + 1, R]
        if (nums[mid] < target)
            left = mid + 1;
        // 不小于目标值，[L, M]全部符合，全部保留 => [L, M]
        else
            right = mid;
    }
    return left;
}
```
该完善版的核心之处在于：
- L < R
- 取整方式与恰当匹配的迭代过程（子区间划分方式）

确保了 L = R 循环终止，且迭代任何阶段必有 T ∈ [L, R] ，且区间长度终将逼近至 1，
即最终有 T = L = R。

### 完整版二分查找算法分析过程

故此完整版的二分查找算法分析过程如下：
> 完整版二分查找算法分析过程：
1. while(L < R)
2. 确定初始 L R
3. 确定迭代方式，根据业务逻辑：
    - 分析何种情况必符合（含等于），何种情况必**不**符合（不含等于）
    - 即分析 M 应划分至左子列还是右子列
4. 确定 M 取整方式，根据迭代方式（子区间划分方式）（分析见上）：
    - M 划分至左子列，子区间为 [L, M] 和 [M + 1, R]：向下取整 —— `M = (L + M) >>> 1`
    - M 划分至右子列，子区间为 [L, M - 1] 和 [M, R]：向上取整 —— `M = (L + M + 1) >>> 1`
5. 考虑目标值不包含在 [L, R] 的特例，并对特例进行前处理或后处理：
    - 优先原则：前、后处理的逻辑简单明了性
    - 若相同则优先前处理
    - 有时同时需要二者

注：
1. 循环迭代过程的确定原则为3，4，分析见补充
2. 前处理和后处理，分析见补充，暂以完善版为例：
    - 前处理：迭代前判断 `nums[nums.length - 1] < target`，则为序列中不存在大于目标值的元素之特例
    - 后处理：迭代完判断 `nums[left] < target`，则为序列中不存在大于目标值的元素之特例

## 补充

### 循环迭代过程的确定原则
上述完善时对修改循环迭代过程的分析不够全面透彻，以下做更为具体的分析，并提出循环迭代过程的确定原则。

4种划分子区间的方式如下图6：

![二分查找_13.jpg](https://cdn.jsdelivr.net/gh/CN-DXTZ/Blog-Img-Bed/PicGo/二分查找_13.jpg)<center>图6</center>

1. 传统版（×），划分 M 为单独项，每次将区间逼近至：[L, M -1 ]，[M] 或 [M + 1, R]
2. 完善版（√），划分 M 至左子列，每次将区间逼近至：[L, M] 或 [M + 1, R]
3. 完善版对称式（√），划分 M 至右子列，每次将区间逼近至：[L, M - 1] 或 [M, R]
4. 错误版（×），重复划分 M 至两子列，每次将区间逼近至：[L, M] 或 [M, R]

先说明1，4为何不好甚至错误：
1 是传统版的迭代方式，该方式的不好之处在于迭代过程中会出现 T ∉ [L, R]，若循环终止条件为 L = R，则可能直接出错（前问已有分析），而若循环终止条件为 L = R + 1，也会陷入繁琐的分析具体返回 left 还是 right。
4 则是完全错误的版本，此方法可以确保在迭代的任何阶段，都有 T ∈ [L, R]，但错误在于不能确保区间长度能逼近至 1，如在迭代的最后阶段，区间长度为 2 时，存在 —— 当 R = L + 1 时，恒有 M ≡ L，若此时 nums[M] < nums[T] 如下图7，则恒有 L = M，迭代陷入死循环，无法停止。

![二分查找_9.jpg](https://cdn.jsdelivr.net/gh/CN-DXTZ/Blog-Img-Bed/PicGo/二分查找_9.jpg)<center>图7</center>

再分析2，3 两种方式为何为正确的划分子区间的方式：
两种方式划分的子区间，既无元素重复，也无元素丢失，可以确保在迭代的任何阶段都有 T ∈ [L, R] ，而再搭配正确的取整方式，即可使区间长度终将逼近至 1，使得最终有 T = L = R。
取整方式分析如下：
- 2：将 M 划分至左子列，按 [L, M] 和 [M + 1, R] 划分子区间，即：
    当 nums[M] >= nums[T] 时，R = M，
    当 nums[M] < nums[T] 时，L = M + 1 ，
    故应使 M ∈ [L, R**)**，才可以恰好取到两端值（R = M(= L) 或 L = M + 1(= R)）
    故取中间值时是应**向下取整**：`M = (L + M) >>> 1`
- 3：将 M 划分至右子列，按 [L, M - 1] 和 [M, R] 划分子区间，即：
    当 nums[M] <= nums[T] 时，L = M，
    当 nums[M] > nums[T] 时，R = M - 1 ，
    故应使 M ∈ **(**L, R]，才可以恰好取到两端值（L = M = R 或 R = M - 1 = L）
    故取中间值时是应**向上取整**：`M = (L + M + 1) >>> 1`

故有了循环迭代过程的确定原则（即[完整版二分查找算法分析过程 3，4](#完整版二分查找算法分析过程)）：
3. 确定迭代方式，根据业务逻辑：
    - 分析何种情况必符合（含等于），何种情况必**不**符合（不含等于）
    - 即分析 M 应划分至左子列还是右子列
4. 确定 M 取整方式，根据迭代方式（子区间划分方式）（分析见上）：
    - M 划分至左子列，子区间为 [L, M] 和 [M + 1, R]：向下取整 —— `M = (L + M) >>> 1`
    - M 划分至右子列，子区间为 [L, M - 1] 和 [M, R]：向上取整 —— `M = (L + M + 1) >>> 1`

**例：**
[LeetCode 69. x 的平方根](https://leetcode-cn.com/problems/sqrtx)：
实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

分析：
1. while(L < R)
2. 非负整数的平方根，最小可能是 0，最大可能是它自己：L = 0，R = x
3. **结果只保留整数的部分，故必符合的条件为：M * M <= x，故 L = M，即 M 划分至右子列**
4. **M 划分至右子列：向上取整 —— `M = (L + M + 1) >>> 1`**
5. 无特例

代码：
```java
public int mySqrt(int x) {
    long min = 0, max = x;
    while (min < max) {
        long mid = (min + max + 1) >>> 1;
        if (mid * mid <= x)
            min = mid;
        else
            max = mid - 1;
    }
    return (int) min;
}
```
### 目标值不确定在目标序列内

### 中位数加 "#" 技巧
二分查找常和中位数一起使用  